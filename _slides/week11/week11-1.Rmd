---
title: "$2^{K - p}$ Designs"
author: "Kris Sankaran | UW Madison"
output:
  xaringan::moon_reader:
    css: ["default", "css/xaringan-themer.css"]
    lib_dir: libs
    nature:
      highlightStyle: github
      highlightLines: true
      countIncrementalSlides: false
      ratio: "16:9"
    seal: false  
---

```{r setup, echo=FALSE}
library(knitr)
library(ggplot2)
opts_chunk$set(echo = FALSE, message = FALSE, warning = FALSE, cache = FALSE, dpi = 200, fig.width = 6, fig.height = 2.8, dev = 'svg', dev.args = list(bg = "transparent"))
theme424 <- theme_minimal() + 
  theme(
    panel.grid.minor = element_blank(),
    panel.background = element_rect(fill = "#f7f7f7"),
    panel.border = element_rect(fill = NA, color = "#0c0c0c", size = 0.6),
    axis.text = element_text(size = 14),
    axis.title = element_text(size = 16),
    legend.position = "bottom"
  )
theme_set(theme424)
```

```{r}
# helper functions
aliases <- function(fit, trim = TRUE) {
  X <- model.matrix(fit)
  pattern <- t(X) %*% X
  pattern[lower.tri(pattern, diag = TRUE)] <- NA 
  pattern <- pattern %>%
    as.data.frame() %>%
    add_rownames("effect") %>%
    pivot_longer(-effect, names_to = "alias") %>%
    filter(effect != alias)
  
  if (trim) {
    pattern <- pattern %>%
      filter(value != 0) %>%
      select(-value)
  }
  
  pattern
}
```

# $2^{K - p}$ Designs
```{r, out.width = 350, fig.align = "left"}
include_graphics("https://uwmadison.box.com/shared/static/mmj9mcixl4y0o95hwf7h93vayw0eooc0.png")
```

### Statistical Experimental Design

.large[Kris Sankaran | UW Madison | November 16, 2021]

---

### Today

* Book Sections: 8.3 - 8.4
* Online Notes: Week 11 [1]

---

### Motivation

* $2^{K - 1}$ designs allow us to draw similar conclusions as $2^{K}$ designs
using only half of the samples
* The approach can be generalized: A $2^{K - p}$ design allows us to use only
$\frac{1}{2^{p}}$ samples of the full design
  - E.g., $\frac{1}{4}, \frac{1}{8}, \frac{1}{16}\dots$

---

### Recipe

1. Build a full factorial design from $K - p$ of the factors. The associated
full factorial is called the _basic design_.
2. Choose $p$ generating relations, which confound the remaining $p$
factors with terms from the full factorial design. 
3. Extend the table using the the relations in (2). This table specifies which
factors should be active in each run.

---

### Conceptual Example

* We will consider an example with 6 factors, A, ..., F.
* We will build a $2^{6 - 2}$ design
  - A $2^{6}$ design would require 64 samples
  - The $2^{6 - 2}$ design only requires 16 samples

---

### Step 1: Setup the Basic Design

* We will choose the full factorial based on A, ..., D.
  - We could have used any subset of 4 factors

| A | B | C	| D |
| --- | --- | --- | --- |
| - | - | - | - |
| + | - | - | - |
| - | + | - | - |
| - | - | + | - |
| - | - | - | + |
| + | + | - | - |
| + | - | + | - |
| + | - | - | + |
| - | + | + | - |
| - | + | - | + |
| - | - | + | + |
| + | + | + | - |
| + | + | - | + |
| + | - | + | + |
| - | + | + | + |
| + | + | + | + |

---

### Step 2: Choose Complete Defining Relations

* We will use $E = ABC$ and $F = BCD$, with the hope that aliasing $E$ and $F$
high-order interactions will give us high resolution.
* Definition: The complete defining relations are the products of columns that
would give the all ones column.
  * This is useful for discussing a design with others, since there are many
  choices that have to be made while constructing $2^{K - p}$ designs
  * For this design, they are $ABCE = BCDF = ADEF = I$

---

### Step 3: Extending the Table

Multiply across the generating relations to choose settings for E and F.

| A | B | C	| D | E = ABC | F = BCD |
| --- | --- | --- | --- | --- | --- |
| - | - | - | - | - | - |
| + | - | - | - | + | - |
| - | + | - | - | + | + |
| - | - | + | - | + | + |
| - | - | - | + | - | + |
| + | + | - | - | - | + |
| + | - | + | - | - | + |
| + | - | - | + | + |  + |
| - | + | + | - | - | - |
| - | + | - | + | + | - |
| - | - | + | + | + | - |
| + | + | + | - | + | - |
| + | + | - | + | - | - |
| + | - | + | + | - | - |
| - | + | + | + | - | + |
| + | + | + | + | + | + |

---

###  Alias Groups

Based on the complete defining relations, we can find all alias groups (multiply
by each factor). In practice, we would be able to use code.

.pull-left[
\begin{align}
  I&=A B C E=B C D F=A D E F \\
  A&=B C E=D E F=A B C D F \\
  B&=A C E=C D F=A B D E F \\
  C&=A B E=B D F=A C D E F \\
  D&=B C F=A E F=A B C D E \\
  E&=A B C=A D F=B C D E F \\
  F&=B C D=A D E=A B C E F \\
  A B&=C E=A C D F=B D E F \\
\end{align}
]

.pull-right[
\begin{align}
  A C&=B E=A B D F=C D E F \\
  A D&=E F=B C D E=A B C F \\
  A E&=B C=D F=A B C D E F \\
  A F&=D E=B C E F=A B C D \\
  B D&=C F=A C D E=A B E F \\
  B F&=C D=A C E F=A B D E \\
  A C D&=B D E=A B F=C E F \\
  A B D&=C D E=A C F=B E F
\end{align}
]

---

### Resolution

A fractional design has resolution $R$ if no $p$-factor effect is aliased with
an effect containing less than $R - p$ factors.

| $R$ | $p$ | $< R - p$ | Interpretation |
|- | - | --- | ------- |
| 3 | 1 |  $\leq 2$ | Main effects aren't aliased with other main effects, but could be aliased with two-way interactions | 
| 4 | 1 | $\leq 3$ | Main effects aren't aliased with any other main effects or with any two-way interactions, but could be aliased with three-way interactions | 
|  | 2 | $\leq 2$ | Two-way interactions aren’t aliased with main effects.
| 5 | 1 | $\leq 4$ | Main effects aren’t aliased with other main effects, two-way, or three way interactions. | 
| | 2 | $\leq 3$ | Two-way interactions aren’t aliased with with main effects or two-way interactions. |

A table of fractional factorial designs and their resolutions is available in
the appendix of the textbook. They can be looked up based on the design's
generator.

---

### Resolution

The resolution is 4. Two-way interactions are confounded with one another, but
not with any main effects.

.pull-left[
\begin{align}
  I&=A B C E=B C D F=A D E F \\
  A&=B C E=D E F=A B C D F \\
  B&=A C E=C D F=A B D E F \\
  C&=A B E=B D F=A C D E F \\
  D&=B C F=A E F=A B C D E \\
  E&=A B C=A D F=B C D E F \\
  F&=B C D=A D E=A B C E F \\
  A B&=C E=A C D F=B D E F \\
\end{align}
]

.pull-right[
\begin{align}
  A C&=B E=A B D F=C D E F \\
  A D&=E F=B C D E=A B C F \\
  A E&=B C=D F=A B C D E F \\
  A F&=D E=B C E F=A B C D \\
  B D&=C F=A C D E=A B E F \\
  B F&=C D=A C E F=A B D E \\
  A C D&=B D E=A B F=C E F \\
  A B D&=C D E=A C F=B E F
\end{align}
]

---

# Code Implementation

---

### Injection Modeling Dataset

.pull-left[
The injection molding dataset has 6 factors,
* A: mold temperature
* B: screw speed
* C: holding time
* D: cycle time
* E: gate size
* F: holding pressure
and the response variable is mold shrinkage.

We will use the $2^{6 - 2}$ design that we just built.
]

.pull-right[
```{r, echo = TRUE}
injection <- read_table2("https://uwmadison.box.com/shared/static/uxd6sryqz32gbubwfhbdvsnqqkplqqef.txt") %>%
  mutate_at(vars(A:F), code)
head(injection, 4)
```
]

---

### Alias Groups

.pull-left[
* From the full model, we can determine the largest effects
* The `aliases` function from last lecture can still be used
* There are many aliases, but skimming through quickly confirms that the design is resolution 4 (like we deduced earlier)
]

.pull-right[
```{r, echo = TRUE}
fit <- lm(Shrinkage ~ A * B * C * D * E * F, injection)
aliases(fit)
```
]

---

### Daniel Plot

.pull-left[
Based on the Daniel plot, it seems that a submodel based on just A, B, and AB
should be sufficient (perhaps an argument could be made for ACD and AD, though).
]

.pull-right[
```{r, fig.width = 5, fig.height = 5, echo = TRUE}
daniel_plot(2 * coef(fit)[-1])
```
]

---

### Fitted Submodel

.pull-left[
Both mold temperature and screw speed affect shrinkage. Moreover, there is an
interaction; i.e., screw speed has a different effect on shrinkage depending on
the underlying mold temperature.
]

.pull-right[
```{r, echo = TRUE}
fit <- lm(Shrinkage ~ A * B, data = injection)
summary(aov(fit))
```
]

---

### Exercise

This walks through textbook problem 8.5.

.pull-left[
In example 6.6, a $2^{4}$ factorial design was used to improve the response rate
to a credit card mail marketing offer. Suppose that the researchers had used the
$2^{4 - 1}$ fractional factorial design with $I = ABCD$ instead. Setup the
design and select the responses for the runs from the full factorial data in
Example 6.6. Analyze the data and drew conclusions. Compare your findings with
those of the full factorial.
]

.pull-right[
```{r, echo = TRUE}
library(readr)
read_csv("credit_card.csv")
```
]

---

### Exercise

This walks through Problem 8.10 in the textbook. 

.pull-left[
Analyze the [data](https://tinyurl.com/37cznbt6) (https://tinyurl.com/37cznbt6)
in Problem 6.26 as if it came from a  design with $I=ABCD$. Project the design
into a full factorial in the subset of the original four factors that appear to
be significant.
]

.pull-right[
For reference,

6.26:	In a process development study on yield, four factors were studied, each
at two levels: time (A), concentration (B), pressure (C), and temperature (D). A
single replicate of a $2^4$ design was run, and the resulting data are shown
here.

a. Construct a Daniel plot. Which factors have large effects?
b. Conduct an ANOVA using the Daniel plot for guidance. What are your conclusions?
c. Write down a regression model relating yield to important process variables.
]

---

We first read in the data and manually code the factors. Next, we filter to the
rows where $ABCD = 1$, to simulate a $2 ^ {4 - 1}$ design.

```{r, echo = TRUE}
library(readr)
library(dplyr)
experiment <- read_csv("https://tinyurl.com/37cznbt6") %>%
  mutate(
    A = ifelse(A == 3, 1, -1),
    B = ifelse(B == 18, 1, -1),
    C = ifelse(C == 80, 1, -1),
    D = ifelse(D == 250, 1, -1)
  ) %>%
  filter(A * B * C * D == 1)
```

---

From the Daniel plot, the terms $AC, C, A, BC$ and $D$ stand out. Note that we
adjusted the `probs` argument so that the effects had tails that were heavier
than normal.

```{r, echo = TRUE}
daniel_plot <- function(effects, probs = c(0.2, 0.3)) { 
  qq <- qqnorm(effects, datax = TRUE, ylim = c(-4.8, 4.8)) # show the labels
  qqline(effects, col = "red", probs = probs, datax = TRUE)
  text(qq$x, qq$y, names(effects), pos=4)
}

fit <- lm(Yield ~ A * B * C * D, experiment)
effects <- 2 * coef(fit)[-1]
daniel_plot(effects) # need heavier tails than normal for plot to make sense
```

---

.pull-left[
```{r}
library(tidyr)
library(tibble)

aliases <- function(fit) {
  X <- model.matrix(fit)
  t(X) %*% X  %>%
    as.data.frame() %>%
    rownames_to_column("effect") %>%
    pivot_longer(-effect, names_to = "alias") %>%
    filter(value != 0, effect != alias) %>%
    select(-value)
}

aliases(fit)
```
]

.pull-right[
The alias groups, together with the fact that the A and D (but not B) main
effects are significant, suggest that the displayed BC effect actually an AD
interaction.
]

---

Based on the Daniel plot, we should fit the model `A + D + A:C + A:D`, which is
equivalent to `A * (C + D)`. All effects are marginally significant. With so few
samples, it is hard to claim that these effects are definitively real, but they
all seem worth following up.

```{r, echo = TRUE, fig.width = 4, fig.height = 4}
fit <- lm(Yield ~ A * (C + D), experiment)
summary(aov(fit))
```
