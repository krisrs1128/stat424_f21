---
title: "Blocking and Mixtures in Response Surface Design"
author: "Kris Sankaran | UW Madison | 23 September 2021"
output:
  xaringan::moon_reader:
    css: ["default", "css/xaringan-themer.css"]
    lib_dir: libs
    nature:
      highlightStyle: github
      highlightLines: true
      countIncrementalSlides: false
      ratio: "16:9"
    seal: false  
---

```{r setup, include=FALSE}
library(knitr)
library(ggplot2)
opts_chunk$set(echo = FALSE, message = FALSE, warning = FALSE, cache = TRUE, dpi = 200, fig.width = 6, fig.height = 2.8, dev = 'svg', dev.args = list(bg = "transparent"))
theme424 <- theme_minimal() + 
  theme(
    panel.grid.minor = element_blank(),
    panel.background = element_rect(fill = "#f7f7f7"),
    panel.border = element_rect(fill = NA, color = "#0c0c0c", size = 0.6),
    axis.text = element_text(size = 14),
    axis.title = element_text(size = 16),
    legend.position = "bottom"
  )
theme_set(theme424)
```

# Blocking and Mixtures in Response Surface Design

```{r, out.width = 200}
include_graphics("https://uwmadison.box.com/shared/static/a8jqduhcmjzj9re22a81236k3enbtzzn.png")
```
### Statistical Experimental Design

.large[Kris Sankaran | UW Madison ]

---

### Today

* Book Sections: 11.4, 11.6
* Online Notes: Week 13 [1] and [3] (skip [2])

---

### Motivation

* At each step in a response surface design, we may encounter nuisance variation
* While sampling for a first-order model, 
  - The operators may change
  - A batch of material might be exhausted
  - Might switch from weekend to weekday in an online shop
* How can we adapt our earlier intuition about blocking to the response surface

---

### Toy Problem: Two Factors

.pull-left[
* Imagine running a central composite design with center points
* There are 14 (= 4 factorial + 4 axial + 6 central) samples to collect, but any
one operator can only collect 7 at a time
* How should we distribute the sampling points across blocks?
  - What would be a bad way to split the points?
]

.pull-right[
```{r}
include_graphics("https://krisrs1128.github.io/stat424_f21/posts/2021-08-17-week12-4/week12-4_files/figure-html5/unnamed-chunk-5-1.png")
```
]

---

### Intuition: Two Factors

* The main idea is to tie blocks together at the center points. 
* Since the runs at central points should be the same (on average), any
systematic difference is an unwanted block effect
* Remaining points are distributed to axial and factorial points
   - This ensures each block is evenly spread across low and high settings
* This intuition works even with larger $K$

.pull-right[
```{r, fig.cap = "By tying sampling center points in both the axial and factorial blocks, it becomes possible to estimate and correct for block effects."}
display(readImage("https://uwmadison.box.com/shared/static/hxsz37wvxcj93osymlckvep6da6ipoqy.png"))
```
]

---

###  More than Two Blocks

* Note that we have limited ourselves to the two-block case
* In general, we follow the same approach as blocking fractional factorial
designs, but with center points tied together
  - Higher order interactions become confounded with the block ID
  - The associated assignments tend to be distributed across the cube
  - The axial points all belong to one block
* See the code example

---

# Code Implementation

---

### Blocking a Design

The default for `ccd` blocks the axial and factorial points.

.pull-left[
```{r}
library(rsm)

codings <- list(time_coded ~ (time - 35) / 5, temp_coded ~ (temp - 150) / 5)
ccd_design <- ccd(~ time_coded + temp_coded, coding = codings)
```
]

.pull-right[
```{r}
head(ccd_design)
```
]

---

### Visualization

Note that we recovered the original temperature and time units using the
`decode.data` function.

.pull-left[
```{r, echo = FALSE, fig.cap = "A central composite design with factor combinations shaded in by the batch from which them emerged."}
ggplot(decode.data(ccd_design)) +
  geom_jitter(aes(time, temp, col = Block)) +
  scale_color_brewer(palette = "Set2") +
  coord_fixed()
```
]

---

### More than 2 Blocks

.pull-left[
* The `blocks` argument to `ccd` allows us to define generators to use during
block construction.
* The generators here are (ABC, CDE). This creates 5 blocks.
  - Four blocks of $2^{5 - 2}$ samples, each of which is a fractional factorial
  - One block of axial points
]

.pull-right[
```{r}
codings <- list(time_ ~ (time - 35) / 5, temp_ ~ (temp - 150) / 5, 
                power_ ~ power, rate_ ~ rate, cooling_ ~ cooling)
blocked_ccd <- ccd(
  ~ time_ + temp_ + power_ + rate_ + cooling_, 
  coding = codings, 
  blocks = Block ~ c(time_ * temp_ * power_, power_ * rate_ * cooling_)
)
```
]

---

```{r, out.width = 700}
ggplot(decode.data(blocked_ccd)) +
  geom_jitter(aes(time, temp, col = Block)) +
  scale_color_brewer(palette = "Set2") +
  coord_fixed()
```

---

# Mixture Experiments

---

### Motivation

* In many problems, we want to find an optimal mixture of ingredients
  - What proportion of the synthetic material should come from different
  sources?
  - How much of the computational budget should be allocated to different
  hyperparameter searches?
* Mixture experiments have a specific geometry which is not respected by the
response surfaces covered so far
  - All the parts have to sum up to 1

---

### Simplex Geometry

* $P$: Total number of ingredients
* $x_{p}$: The fraction of ingredient $p$

Then we have the constraints,

* Data are proportions: $x_{p} \in \left[0, 1\right]$
* Sum to One: $\sum_{p = 1}^{P} x_{p} = 1$

---

### Simplex Geometry

* The set of $x = \left(x_{1}, \dots, x_{P}\right)$ satisfying these constraints
is called the simplex,
  * Center point has an equal amount of each ingredient
  * Corners have 100% coming from one of the ingredients
* Factorial and central composite designs can't be used -- they might fall off
the edges

---

### Simplex Lattice Design

.pull-left[
* Draw a grid with spacing $\frac{1}{m}$ in each direction in $p$-dimensional
space
* Discard all points that don't lie on the simplex
* The parameter $m$ controls the granularity of the sampling points.
]

.pull-right[
```{r, fig.cap = "An SLD with m = 3." }
library(mixexp)
DesignPoints(SLD(3, 3))
```
]

---

### Simplex Lattice Design

.pull-left[
Consider combinations of integers $k_{p} \in \{0,1, \dots, m\}$ such that
$\sum_{p = 1}^{P} k_{p} = m$. The SLD$(m)$ design places samples at,
\begin{align*}
\frac{1}{m}\left(k_{1}, \dots, k_{P}\right)
\end{align*}
The parameter $m$ controls the granularity of the sampling points.
]

.pull-right[
```{r, fig.cap = "An SLD with m = 5." }
library(mixexp)
DesignPoints(SLD(3, 5))
```
]

---

### Simplex Centroid Design

.pull-left[
* Corners: Permutations of the vector $\left(1, 0, \dots, 0\right)$.
* Edge midpoints: Add permutations of $\left(\frac{1}{2}, \frac{1}{2}, 0, \dots, 0\right)$.
* Face centroids: Add permutations of $\left(\frac{1}{3}, \frac{1}{3}, \frac{1}{3}, 0, \dots, 0\right)$.
* .. continue the pattern until meet sample size limit
]
	
.pull-right[
```{r, fig.cap = "An SCD with 5 sample points." }
head(SCD(5))
```
]

---

### Fitting Surfaces

.pull-left[
Once we have samples along the simplex, we can use our earlier methods for
estimating a response surface on it
  * Can still fit polynomial or spline regression
]

.pull-right[
```{r}
library(readr)
yarn <- read_csv("https://uwmadison.box.com/shared/static/jghwbsnn6qjpwdr1lc97p9mbxk8qkwif.csv")
fit <- lm(elongation ~ -1 + (x1 + x2 + x3) ^ 2, data = yarn)
ModelPlot(
  fit, 
  dimensions = list(x1 = "x1", x2 = "x2", x3 = "x3"), 
  contour = TRUE
)
```
]

---

```{r}
opts_chunk$set(echo = TRUE)
```

### Code Implementation

---

### Simplex Designs

.pull-left[
* We can use the `mixexp` package to find points along lattice and centroid
designs
* The `DesignPoints` function visualizes the resulting designs
]

.pull-right[
```{r}
library(mixexp)
head(SLD(3, 3)) # first argument is # of factors
head(SCD(3))
```
]

---

### Simplex Designs

.pull-left[
* We can use the `mixexp` package to find points along lattice and centroid
designs
* The `DesignPoints` function visualizes the resulting designs
]

.pull-right[
```{r}
library(mixexp)
DesignPoints(SLD(3, 3))
```
]

---

### Simplex Designs

.pull-left[
* We can use the `mixexp` package to find points along lattice and centroid
designs
* The `DesignPoints` function visualizes the resulting designs
]

.pull-right[
```{r}
library(mixexp)
DesignPoints(SCD(3))
```
]

---

### Dataset

In the yarn dataset, an experiment used a (3, 2) SLD to measure variation in
yarn elongation as a function of the fractions of materials used to make the
base fiber.

```{r}
library(readr)
yarn <- read_csv("https://uwmadison.box.com/shared/static/jghwbsnn6qjpwdr1lc97p9mbxk8qkwif.csv")
head(yarn)
```

---

### Model Fitting

* The code below fits a quadratic model with second order interactions over the
simplex.
* We omit the intercept term using `-1`
  - An intercept column would introduce a collinearity (mixture columns sum to
  1)

```{r}
fit <- lm(elongation ~ -1 + (x1 + x2 + x3) ^ 2, data = yarn)
summary(fit)
```

---

### Visualization

.pull-left[
* `ModelPlot` function shows the response surface over mixture components.
* We can change the `dimensions` argument whenever there are more than 3 mixture
components
]

.pull-right[
```{r, echo = TRUE, fig.margin = FALSE, fig.width = 10}
ModelPlot(
  fit, 
  dimensions = list(x1 = "x1", x2 = "x2", x3 = "x3"), 
  contour = TRUE
)
```
]

---

### Exercise

---